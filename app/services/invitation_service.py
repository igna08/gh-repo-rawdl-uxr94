from datetime import datetime, timedelta
from uuid import UUID

from fastapi import HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import select, and_

from app.models.invitation import Invitation
from app.schemas.invitation import InvitationCreate
from app.core.config import settings


def create_invitation(db: Session, invitation_in: InvitationCreate, sent_by: UUID) -> Invitation:
    """
    Creates a new invitation.
    Checks for existing active invitations for the email before creating.
    """
    # Check if an active (not used and not expired) invitation already exists
    existing_invitation_stmt = select(Invitation).where(
        and_(
            Invitation.email == invitation_in.email,
            Invitation.used_at.is_(None),
            Invitation.expires_at > datetime.utcnow()
        )
    )
    existing_invitation = db.execute(existing_invitation_stmt).scalars().first()

    if existing_invitation:
        raise HTTPException(
            status_code=400,
            detail="Active invitation already exists for this email."
        )

    # Create new Invitation ORM object
    new_invitation = Invitation(
        email=invitation_in.email,
        role_id=invitation_in.role_id,
        school_id=invitation_in.school_id,
        sent_by=sent_by,
        expires_at=datetime.utcnow() + timedelta(hours=settings.INVITATION_TOKEN_EXPIRE_HOURS)
        # token and id are generated by default by the model
    )

    db.add(new_invitation)
    db.commit()
    db.refresh(new_invitation)
    return new_invitation


def get_invitation_by_token(db: Session, token: UUID) -> Invitation | None:
    """
    Retrieves an invitation by its token.
    """
    statement = select(Invitation).where(Invitation.token == token)
    invitation = db.execute(statement).scalars().first()
    return invitation


def mark_invitation_as_used(db: Session, token: UUID) -> Invitation | None:
    """
    Marks an invitation as used by setting the used_at timestamp.
    """
    invitation = get_invitation_by_token(db=db, token=token)

    if invitation:
        if invitation.used_at is not None:
            # Optionally, you might want to raise an exception or handle this case differently
            # For now, just return the invitation as it's already marked used.
            # Or, if marking again should not happen, raise HTTPException
            # raise HTTPException(status_code=400, detail="Invitation already used.")
            pass # Or log a warning, depending on desired behavior for re-marking.
        
        invitation.used_at = datetime.utcnow()
        db.add(invitation)
        db.commit()
        db.refresh(invitation)
        return invitation
    
    return None
